{"pages":[{"title":"tags","text":"","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"Pixijs 动画制作教程","text":"本次要介绍的Pixijs 是一个 HTML5 的 2D 渲染引擎，支持 Canvas 和 Webgl 两种方式渲染。使用 Pixijs 可以制作几乎所有的 2D 动画效果，甚至一些简单的小游戏都可以实现。目前在 Github 上，已经有超过 2W star，是最流行的 2D 渲染引擎之一。 Pixijs 采用纯代码开发的形式，虽然开发过程不像 Egret 和 Coco2d 有图形化工具方便，但是该开发过程十分灵活，并且能够与其他业务系统进行无缝对接，是很多前端动画开发者的最爱。本场 Chat 就让我们来研究一下，Pixijs 是如何制作动画的。 本场 Chat 包括： Pixijs 安装和使用简介；Pixijs 动画元素渲染；Pixijs 事件处理；Pixijs 必备的插件。 本场Chat，我们来研究一下Pixijs这一强大的2D渲染引擎。在进入正题之前，先简单介绍一下Pixijs。单从名字上我们就知道，这是一个js库，跟Jquery、Vue和React等等的这些库一样。而Pixijs最主要做的是：渲染即把图片、SVG、模型等等的东西，生成到页面中。 Pixijs安装和使用简介 Pixijs动画元素渲染 Pixijs事件处理 Pixijs必备的插件 Pixijs安装和使用简介 Pixijs 安装由于Pixijs是一个js库，所以安装方法跟一般的js库一样：1&lt;script src=&quot;pixi.min.js&quot;&gt;&lt;/script&gt; 或者通过npm\\yarn安装12npm install pixi.jsyarn add pixi.js 安装之后，在控制台的console中，会出现Pixijs特有的log提示，看到了这个，就表示项目中使用到了Pixijs。1PixiJS 4.4.5 - * canvas * http://www.pixijs.com/ ♥♥♥ Pixijs 使用Pixijs使用方法非常简单，最基本的代码，就是：123let app = new PIXI.Application({width: 256, height: 256});...document.body.appendChild(app.view); 这里调用PIXI.Application方法，创建一个宽度和高度都为256的场景。PIXI.Application方法调用过后，会返回一个canvas对象，把该对象加入到dom当中，一个简单的PIXI场景就出现了。 当然，PIXI.Application方法还有很多配置，这个可以到文档中查看详细的介绍：PIXI文档 Pixijs动画元素渲染Pixijs既然是一个渲染引擎，那么它在渲染方面肯定是有独特之处，那究竟Pixijs是如何做渲染的呢。 首先，Pixijs支持Canvas和Webgl两种方式渲染 Canvas方式相信我们都不陌生，是Html5的一个新增的一个画布绘图的功能。 Webgl其实是Opengl在网页浏览器中的应用，专门针对三维视图所出现最新Api。 在Pixijs中，无论是使用Canvas还是Webgl方式，所写的代码都是一样的，只是需要通过PIXI.Application中的forceCanvas来设置是否强制使用Canvas方式即可。 搭建舞台一个Pixijs项目，最开始都是根据需求搭建舞台：12345this.app = new PIXI.Application(this.options.width, this.options.height, { view: this.options.stage, backgroundColor: 0xffffff // forceCanvas: true}) 舞台会有很多属性可以设置，比较重要的是宽、高以及舞台依附的dom元素（view）。然后就是一些可选的设置，包括背景色、是否强制使用canvas、不透明度等等，这些可以根据具体的项目需求进行设置。 预加载元素因为动画和游戏的资源都很多，所以任何一个动画或者游戏框架，都必须有预加载的功能。Pixijs有一个十分强大的加载器：PIXI.loaders。通过loader可以把图片资源预加载到项目中，然后通过onProgress和onComplete方法，就能监听到图片加载情况。12345this.loader = new PIXI.loaders.Loader()this.loader.add(&apos;stage1&apos;, stage1)this.loader.load()this.loader.onProgress.add(progressHandel)this.loader.onComplete.add(handleComplete) 利用loader能够制作项目加载进度的动画 Pixijs通过Sprite、Graphics、TilingSprite等的api，生成场景中的元素日常开发中，最经常用到的是Sprite类，这个用来创建一个精灵：1const car = new PIXI.Sprite(textures[&apos;car1.png&apos;]) 创建了之后，可以用对这个精灵进行各种的操作，比较常见的有以下几个：1234car.setTransform(104, 94) // 设置位置car.anchor.set(0.5) // 设置锚点car.visible = false // 设置隐藏car.alpha = 0.5 // 设置不透明度 设置好各种属性之后，就可以把精灵加入到场景中（一般会给各个场景新建一个Container，把精灵添加到Container中，再把Container添加到舞台中）：12this.stage2 = new PIXI.Container()this.stage2.addChild(car) Pixijs精灵的属性有很多，需要根据具体的需求来设置精灵的属性，更多时候是需要翻查官网PIXI文档。 Pixijs事件处理经过渲染之后，舞台中已经渲染了有很多精灵元素，那么下面就来看看，如何制作交互效果。 Sprite精灵事件精灵中除了有各种属性之外，还提供了大量的事件，基本上涵盖了市面上所有交互需求:123this.againBtn.on(&apos;pointerdown&apos;, e =&gt; { console.log(e)}) 通过on方法，绑定Pixijs中的click、mousedown、mouseup等方法，通过回调的参数e，就可以获取事件中回调的各种参数属性，通过这些参数即可做出各种的效果。这里有几点需要注意： 这些事件中，有一些在手机上才会有效果，例如touch类的方法 需要开启精灵的interactive属性才可以调用成功 事件存在冒泡问题 Pixijs必备的插件Pixijs作为一个渲染引擎，能做的主要的渲染方面的东西，但是要完成一个h5或者游戏，还需要一些辅助的工具才行。这里就介绍一下，用Pixijs开发的时候，必备的几个插件： GSAP动画库 动画是h5和游戏中十分重要的一环，Pixijs中对于动画的支持极其有限，而GSAP恰好能够解决这一问题。GSAP是国外流行的动画库，并且有专门为Pixijs量身定制的插件，是Pixijs的好兄弟。 Pixi-sound Pixijs官网推荐的音频插件，是一个简单的音频播放插件。虽然不及很多大型的音频库功能那么强大，但是一般的h5和小游戏只会播放简单的背景音乐，基本上已经够用了。 Pixi-layers Pixijs官网推荐的层级插件，作用类似用css中的zindex。由于Pixijs基于Canvas，所以如果元素一多的话，叠层的情况就会经常出现；这个时候，如果还是通过代码的添加顺序来区分层级的话，就会十分地混乱。有了Pixi-layers后，可以通过设置z-index来区分层级，十分方便。","link":"/2019/01/02/Pixijs-动画制作教程/"},{"title":"Phaser画中画游戏","text":"这篇文章主要记录，Phaser画中画游戏的制作流程以及制作难点，主要涉及以下几点：项目效果 Phaser横屏适配 搭建图片 长按效果 结束页面 Phaser横屏适配Phaser横屏适配沿用Phaser小站的横屏适配方案注意：一般在preload的时候，就设置横屏了 项目开头，先加入这一段代码；作用是在横屏的时候，让游戏旋转90度123456789101112Phaser.World.prototype.displayObjectUpdateTransform = function () { if (!this.game.scale.correct) { this.x = this.game.camera.y + this.game.width this.y = -this.game.camera.x this.rotation = Phaser.Math.degToRad(Phaser.Math.wrapAngle(90)) } else { this.x = -this.game.camera.x this.y = -this.game.camera.y this.rotation = 0 } PIXI.DisplayObject.prototype.updateTransform.call(this)} 定义一个judgeOrient()方法，在游戏开始的时候和手机方向旋转的时候调用123456789101112131415judgeOrient () { if (this.game.scale.isLandscape) { this.game.scale.correct = true this.game.scale.setGameSize( this.game.optionsWidth, this.game.optionsHeight ) } else { this.game.scale.correct = false this.game.scale.setGameSize( this.game.optionsHeight, this.game.optionsWidth ) }} 搭建图片 搭建图片之前，需要用ps测量几个尺寸： 每一张图片与下一张图片衔接区域的大小 衔接区域的坐标 测量好之后，就可以开始计算几个值： rate 图片缩放的大小 anchorX和anchorY 缩放中心的坐标 areaX和areaY 缩放区域的坐标 12345rate: 1920 / 178 / 2, anchorX: 724 + (178 * 724) / (724 + 1018),anchorY: 494 + (102 * 494) / (494 + 484),areaX: 724,areaY: 494 这里需要注意几点： 这里的游戏逻辑是，把图片从最后一张开始添加（因为后面添加的会叠在上面）。 每次添加都需要把图片放大指定的尺寸，使得图片一开始可以跟前面一张图片重合。 放大之后，需要设置一下图片的缩放中心，这个中心需要经过一些计算 如上图，需要保证x1/y1 = x2/y2，根据这个中心点进行缩放，图片缩放到原始大小的时候，才能正好铺满屏幕 长按效果有了这些数值之后，可以开始制作长按效果，先创建一个长按按钮，绑定两个方法，一个是按下，一个是释放12345678910111213// press btnthis.press = this.game.add.sprite( this.game.optionsWidth / 2, this.game.optionsHeight * 0.8, &apos;press&apos;)this.press.scale.set(0.7)this.press.anchor.set(0.5)this.down = falsethis.press.inputEnabled = truethis.press.events.onInputDown.add(this.onDown, this)this.press.events.onInputUp.add(this.onUp, this) 通过一个变量this.down = true，来控制这个长按效果1234onDown () { ... this.down = true} 在phaser的update中，判断如果this.down为true的话，就开始执行缩放动画，动画逻辑是： 为每一张图片的缩放动画，都设定一个区间，在这个区间内，执行动画，否则，不执行; 12345if (this.p2.width &gt; 0 &amp;&amp; this.p1.width &lt;= this.game.optionsWidth) { // 当前图片宽度大于0 （不能让图片无限缩小） // 前一个图片的宽度小于当前屏幕宽度（前一个图片的宽度小于当前屏幕宽度的时候，当前图片就已经会出现在画面中，这时候就需要对当前图片进行缩小） ...} 核心缩放效果，就是改变当前图片的宽高 123const rate = 0.01nowPage.width = nowPage.width * (1 - rate)nowPage.height = nowPage.height * (1 - rate) 但是除此之外，需要增加一些必要的判断，首先是判断是否为最后一页，如果是最后一页，就不用缩放了，跳到最后的场景123456789101112131415161718if (nextPage === &apos;end&apos; &amp;&amp; nowPage.width &lt;= this.game.optionsWidth * 1.1) { nowPage.prevPage.destroy() nowPage.tween = this.game.add.tween(nowPage).to( { alpha: 0 }, 500, null, true, 0, 0 ) nowPage.tween.onComplete.add(() =&gt; { this.game.state.start(&apos;end&apos;) }, this)} else if (nextPage !== &apos;end&apos;) { nextPage.prevPage = nowPage} 然后，当当前图片宽度已经小于屏幕大小，后面一张图片已经在缩放的时候，需要先把上一个图片销毁掉；因为这个时候，上一个图片已经很小，没必要再去缩放 并且，把当前图片的坐标和缩放中心调整为跟后面一张图片相匹配：这样做目的是因为一开始创建图片的时候，由于图片被放大，所以清晰度不高，如果直接出现在页面上，用户体验不好。所以需要保留之前的一张图片，跟当前的图片一起缩放，这样清晰度就能够保证12345678910111213141516if ( nowPage.width &lt;= this.game.optionsWidth &amp;&amp; nextPage.visible === false &amp;&amp; nextPage !== &apos;end&apos;) { // this.currentPage = nextPage if (nowPage.prevPage) { nowPage.prevPage.destroy() } nowPage.position.set( nextPage.anchor.x * this.game.optionsWidth, nextPage.anchor.y * this.game.optionsHeight ) nowPage.anchor.set(nextPage.anchor.x, nextPage.anchor.y) nextPage.visible = true} 结束页面结束页面难度不大，不过要注意的是分享的弹窗需要最后再添加，不然会被前面的页面挡住；还有就是结束层是一个group，点击动作需要使用onChildInputDown的方法1this.shareGroup.onChildInputDown.add(this.closeShare, this)","link":"/2018/12/03/phaser画中画游戏/"},{"title":"Mockjs + Vue 拦截 AJAX，模拟请求数据","text":"日常工作中，前端通过ajax调用后端的接口是非常常见的事情。然而很多情况下，调用接口也会出现很多不方便或者麻烦的情况。 例如：现在有一个抽奖的项目，分为1，2，3等。后台同事写好接口之后，我们前端通过调用抽奖接口，根据不同的奖品等级出现不同的奖品细节。在这种情况下，我们调用接口会出现一个情况，就是调用10次，可能连一次1等奖都没有，因为1等奖中奖率很低。这个时候，为了能测试1等奖，我们就要想个办法来模拟数据了。Mock.js是一个能够生成随机数据，拦截Ajax请求，实现前后端分离 让前端攻城师独立于后端进行开发的库。本场chat我就来介绍一下，这个库的一些用法。 Mockjs 应用场景介绍 Mockjs 简单使用和配置 Mockjs 搭配 Vue 使用 Mockjs 注意事项 应用场景介绍1.项目流程比较复杂，而后台同事已经完全写好程序之后，可以使用mockjs来模拟数据进行开发测试 2.需要制作案例库或者作品展示之类的项目，需要把原有项目进行处理，去除所有的http请求 3.项目已经上线，但是临时要修改，不想影响线上页面和数据的时候，可以使用mockjs协助 4.后台同事接口还没写完，而前端想调用接口，可以mockjs模拟数据 5.进行单元测试的时候，可以用mockjs随机数据，模拟各种场景 简单使用和配置Mockjs的使用方法并不难，首先安装mockjs（支持各种方式安装） 123npm install mockjsbower install --save mockjs&lt;script type=&quot;text/javascript&quot; src=&quot;./bower_components/mockjs/dist/mock.js&quot;&gt;&lt;/script&gt; 最简单的用法，随机一组数据12345678910import Mock from &apos;mockjs&apos;var data = Mock.mock({ // 属性 list 的值是一个数组，其中含有 1 到 10 个元素 &apos;list|1-10&apos;: [{ // 属性 id 是一个自增数，起始值为 1，每次增 1 &apos;id|+1&apos;: 1 }]})console.log(JSON.stringify(data, null, 4)) MockJs通过在对象属性后面，添加 ‘|XX’的方式，来进行数据的随机生成。也可以使用mock.random方法进行生成数据。在日常开发中，我们常用的数据大概有如下几类：integer、string、date、time、image、color、text、url、name。Mockjs都有对应的方法来生成这些类型的模拟数据。 一般常用的随机方法有下面几个 随机多个重复数据 12345Mock.mock({ &quot;string|1-10&quot;: &quot;★&quot;})★ 随机数字 12345Mock.mock({ &quot;number|1-100&quot;: 100})89 随机bool 12345Mock.mock({ &quot;boolean|1-2&quot;: true})false 随机数组 12345678910111213Mock.mock({ &quot;array|1-10&quot;: [ &quot;Mock.js&quot; ]}){ &quot;array&quot;: [ &quot;Mock.js&quot;, &quot;Mock.js&quot;, &quot;Mock.js&quot; ]} 随机正则 1234567Mock.mock({ &apos;regexp&apos;: /[a-z][A-Z][0-9]/}){ &quot;regexp&quot;: &quot;rJ7&quot;} 随机日期 123Mock.mock(&apos;@date&apos;)&quot;1980-01-05&quot; 随机字符串 123Mock.mock(&apos;@word&apos;)&quot;fbzgdlg&quot; Mockjs还有很多随机的方法可以选择，基本上测试上已经够用的了，我在这里就列出了一些我常用的方法，如果还需要更加高级的可以查看mockjs的文档。 拦截http请求Mockjs一个很好用的功能，就是可以拦截ajax，正因为有了这个方法，使得mockjs能够用来为一些中小型项目提供简单的测试环境。先举一个简单的例子：123456789101112Mock.mock(&apos;http://test.com&apos;,{ &apos;name|3&apos;:&apos;fei&apos;, &apos;age|20-30&apos;:25,})$.ajax({ url:&apos;http://estcom&apos;, dataType:&apos;json&apos;, success:function(e){ console.log(e) }}) 执行之后，会发现netword中没有请求，而ajax会返回我们设定的数据。 Mock方法还有几个参数：Mock.mock( rurl?, rtype?, template|function( options ) )。 rurl表示需要拦截的 URL，可以是 URL 字符串或 URL 正则。 rtype表示需要拦截的 Ajax 请求类型。例如 GET、POST、PUT、DELETE 等。 template表示数据模板，可以是对象或字符串。例如 { ‘data|1-10’:[{}] }、‘@EMAIL’。 function(options)表示用于生成响应数据的函数。 一般使用rurl和template就已经足够模拟接口了，用于测试的请求不需要非常完整，只需要模拟一到两种返回数据类型就可以了。 搭配vue使用现在很多国内项目都是使用Vue进行构建，Mockjs和Vue是可以完美结合的。（建议写一个utils.js文件，专门处理Mockjs的逻辑） main.js 12345678910111213141516171819202122232425262728import Vue from &apos;Vue&apos;import Router from &apos;VueRouter&apos;import utils from &apos;../utils/utils&apos;const router = new VueRouter({routes})const getQueryString = (name) =&gt; { var reg = new RegExp(&apos;(^|&amp;)&apos; + name + &apos;=([^&amp;]*)(&amp;|$)&apos;); var r = window.location.search.substr(1).match(reg); if (r != null) return unescape(r[2]); return null;}if (getQueryString(&apos;static&apos;) === &apos;true&apos;) { ......}Vue.use(Router)new Vue({ el: &apos;#app&apos;, router, template: &apos;&lt;App/&gt;&apos;, components: { App }}) utils.js 12345678910111213141516171819import Mock from &apos;Mock&apos;const utils = { cj(options) { Mock.mock(options.cj, { &apos;statusCode&apos;: &apos;200&apos;, &apos;data&apos;: { &apos;id|1-100000&apos;: 1, &apos;name&apos;: &apos;1元红包&apos;, &apos;type&apos;: &apos;hb:100&apos;, &apos;level&apos;: &apos;五等奖&apos;, &apos;sno&apos;: &apos;pd4mjq&apos; }, &apos;msg&apos;: &apos;恭喜你，中奖了！&apos; }) }}export default utils 有一点需要注意的是，Mockjs需要在new vue()之前执行，不然vue已经初始化了。配置好了之后，在项目中可以对接口不做任何调整，我的方法是用链接带参数static=true的方式，生成两个链接，一个正式链接，一个测试链接；然后只需要多写mock的配置，就可以实现正式链接请求后台数据，而测试链接不发送任何请求但项目依然可以完美运行。 12345678910let postData = this.$qs.stringify({ answer_id: this.$route.params.answerId, vdata: vdata})this.$http.request({ method: &apos;post&apos;, url: this.$projectOptions.cj, data: postData}) 正式链接：http://www.test.com 测试链接：http://www.test.com&amp;static=true Mockjs 注意事项 最好通过链接带参数，或者一些标记的方式来调用mockjs，这样在不需要做太多调整，就能弄出测试和正式环境。 由于Mockjs修改了XHR对象，对于一些通过XHR获取资源（例如createjs用preloadjs加载图片）的库需要注意设置成不使用XHR方式加载。 Mockjs虽然很好用，但是在大项目中，其实并不合适，最正规的测试应该是搭建测试服务器进行测试。只是在一些中小型公司，没有这样的资源，可以使用这一个折中的办法。 Mockjs的模拟数据虽然已经很全面，但是随着需求的变更，肯定会有无法模拟的时候，这个时候可以使用其他随机数据的库，配合mock使用 Mockjs已经有一段时间没有更新了，不过很多测试框架像Jest都提供mock方法，如果在时间充裕并需要正规地进行项目测试，建议使用专业的测试框架进行单元测试","link":"/2018/11/30/AJAX，模拟请求数据/"},{"title":"前端游戏框架哪个好","text":"当今国内外流行的游戏开发框架有哪些开发动画和游戏，跟我们做数据交互不一样；游戏和动画开发起来比较复杂和耗时，是比较依赖框架和工具的。那么现在都有那些框架和工具呢？下面我们就来看一下。 Name 2D 3D Three.js no yes Phaser yes no Createjs yes no Egret yes yes Cocos2d-js yes no 每个框架的特点以及优缺点上面表格的框架，是我总结出来，比较多同行关注并且学习使用的框架。 Three.js一款历史比较悠久的开源项目，准确地说它不是一个游戏引擎，是一个JavaScript的3D库。然而我们可以用它来做各种的3D效果和游戏。 优点： 专注于三维效果的JavaScript实现，能够在网页端实现大部分三维效果 文档齐全，并具有搜索功能，方便快速查阅 国外项目，目前仍然持续更新，不需要担心没人维护国外 纯js代码开发，引入库即可用，不需要借助其他工具，方面接入任何的系统 缺点： 文档大部分是英文，需要具备一定英文水平才能读懂 学习难度比较大，除了js代码基础，还需要具备高中的几何知识、webgl知识、线性代数等等 国内例子相对比较少，中文教程也不多，基本上都是看官网的例子和文档进行学习和研究 网页3d效果的兼容性和性能问题，需要详细研究需求后才能使用 Phaser免费开源的html5游戏框架，支持canvas和webgl渲染，github上2w+ star，比较不错的游戏框架。 优点： 专注于2d游戏的JavaScript实现，集合了渲染、物理引擎，能够完成大部分小游戏 使用方法简单，容易上手 官方网站上有大量例子，代码都不负责，基本需要使用的效果都能找到对应的例子 纯js代码开发，引入库即可用，不需要借助其他工具，方面接入任何的系统 能够在微信小游戏中使用，并支持typescript 缺点： 官方文档大部分是英文，并且没有搜索功能，需要按照类一层层往下搜索；假如在官方例子中找不到合适的代码，需要花时间研究文档 目前稳定版本是2.10，但是版本是社区维护；官方在开发新的3.0版本，暂时还在调整阶段 由于纯代码编写，如果游戏逻辑复杂，代码会比较多和繁琐，需要在前期做比较好的规划 Createjs免费开源的html5游戏、动画和交互应用框架，adobe animate软件基于该库来生成代码。 优点： 动画和交互效果小能手，众多好看和高质量的h5展示效果使用createjs制作 可以使用纯代码开发，或者使用adobe animate软件开发 国内教程比较丰富，学习成本不大 核心库分为四个，分别支持渲染、动画、预加载和音频，可以按需求加载对于库 缺点： 例子相对较少，遇到新或者复杂的需求，基本需要查看api，无法寻找相似例子 没有封装好粒子系统、骨骼动画、瓦片地图等等，轻量级的库，不适合大型游戏 动画制作一般需要大量图片，涉及图片压缩和使用精灵图方面的技术 Egret国内优秀的游戏制作引擎，具备一整套的开发工具和教程。 优点： 大型游戏制作能手，能够使用图形化工具制作游戏，性能优越 使用typescript开发业务逻辑，代码规范 中文文档和教程，学习方便 同时支持3d和2d，并且带有各种模块，游戏制作基本属于全能 支持接入微信小游戏 缺点： 需要使用工具开发，不方便接入其他业务系统 虽然具备中文文档，当时需要熟悉各种工具，学习成本不低 例子相对较少，制作大型游戏需要大量填坑 Cocos2d-js历史比较悠久的游戏开发框架，类似egret。 优点： 2D优秀开发引擎，同样使用图形化工具制作游戏，操作方便 核心使用JavaScript编写 中文文档和教程，学习方便，并且资料和例子丰富 功能相当完整，游戏中需要的功能几乎都能够找到 支持接入微信小游戏 缺点： 需要使用工具开发，不方便接入其他业务系统 需要熟悉各种工具，学习成本不低，这点类似egret 擅长2D游戏开发，3D游戏开发没有其它几个游戏框架专业 怎样去选择一个适合的框架来学习和使用学习：从学习上来说，我推荐初学者挑选纯代码进行开发的框架（three.js、createjs和phaser）进行学习。学习这类型的框架，虽然难度比较大，花时间比较长；但是能够提高自己的代码编写水平，还能更加深刻地理解游戏开发。 如果有些小伙伴比较喜欢图形化界面操作，也可以尝试egret和coco2d。这两个框架都是国内比较流行的游戏框架，学习哪一个都会有所帮助。 如果有小伙伴之前是做flash的，我推荐使用adobe animate软件。这款软件其实就是以前的flash加上了html5的canvas，它既可以生成flash，也可以制作网页动画；制作的方法也以前的flash软件基本一样，只是多了JavaScript代码编写。 工作：在工作中，特别是一些中小型公司，选择游戏框架就跟学习的时候不一样了。首先需要明确需要制作什么类型的游戏，是否需要接入自己公司的业务系统。 如果是一些小游戏，类似跳一跳、推箱子等等，可以使用纯代码开发的框架。这样无论后面需求是否修改，是否需要接入业务系统，都能够方便进行修改。 如果游戏的形式不太清晰，但是需要接入自己业务系统，例如游戏过后要抽奖、要统计数据等等；也建议优先选择纯代码开发的框架，毕竟纯代码开发的框架，就算前后端没有完全分离，也可以在页面上面放php或者java代码。 如果需要制作比较复杂的游戏，图形化的开发工具是第一选择。图形化界面能够大大提升游戏开发的效率，而且游戏的结构也是清晰可见，性价比比较高。 如果游戏需求比较复杂，而且需要接入自己的业务系统。这种情况，需要先测试图形化工具缩生成的代码是否能够顺利接入系统，然后再选择使用。 使用框架的注意事项最后，给小伙伴们几个使用框架的建议，下面的都是我经过无数次踩坑总结出来的。 学习使用过程，遇到英文资料或者文档，建议不要使用翻译软件，通过例子和上下文去理解。 注意游戏的图片和模型加载，合理使用精灵图和框架的预加载功能。 开始开发之前，注意测试需要用到的框架属性，是否存在兼容性问题，特别是安卓和苹果手机的区别。 多复习一下高中的立体几何、解析几何，大学的线性代数、算法和图形图像。 跟美工打好关系，做游戏时，图片和模型的调整会非常多，没有他们的配合，很难进行。","link":"/2018/11/03/前端游戏框架哪个好/"},{"title":"CreateJS 制作 H5 长图动画","text":"现在移动端高端大气的动画h5非常多，去各大素材网站，或者关注一些大型的公众号，不时就会推出一些新颖的形式。这些移动端的h5除了设计非常地漂亮以外，动画效果也特别棒。我们作为前端程序猿是很有必要去学习怎么样去制作这类型的动画效果。首先要声明一点的是，前端制作稍微复杂的动画和游戏，一般不会使用dom来写的。主要原因有两个 dom制作动画性能不高 dom写复杂动画比较吃力 一般这种动画和游戏，我们会使用canvas来制作，这里介绍一下用createjs这一个动画库来制作一个简单的长图动画，完成的效果：https://www.foshannews.com/zt/2018/wx/jdtp/zc1/#/ 搭建加载场景 搭建长图场景 制作长按效果 添加元素以及元素动画 Createjs搭建加载场景在搭建场景之前，很重要的一步就是要加载资源，createjs有一个专门用于加载资源的库preloadjs。使用这个库可以在场景渲染之前，先加载需要的资源，实现预加载；再配合上一些加载的动画，用户体验会非常好。 首先把图片引用import进来，然后新建一个createjs.LoadQueue，调用on和loadManifest两个方法。在complete里面写上加载完成后需要执行的逻辑即可。 12345678910111213141516import XXX from &apos;../assets/loading-pointer.png&apos;let queue = new createjs.LoadQueue(false)queue.on(&apos;complete&apos;, () =&gt; { ...}, this)queue.loadManifest([ { id: &apos;loadingPointer&apos;, src: loadingPointer }, { id: &apos;loadingProgress&apos;, src: loadingProgress }]) 这里要注意的是，loadManifest这个方法需要在complete后；原因跟canvas的img.onload和img.src一样，为了在浏览器有缓存的情况下，不会出现img.src方法已经调用完成，而onload方法还没有绑定。 制作加载场景有了加载资源这个方法之后，我们制作场景的思路是：出现加载场景-&gt;加载资源-&gt;完成一个资源的加载-&gt;加载场景进度条往前移动 先创建一个container，相当于一个div，来包裹里面的元素，方便后面操作里面的元素 12let stage = new createjs.Stage(options.stage)let container = new createjs.Container() 接下来，通过Shape的graphics方法，绘制一个背景 123let bg = new createjs.Shape()bg.graphics.beginFill(&apos;#b7d45d&apos;).rect(0, 0, this.options.width, this.options.height)container.addChild(bg) 有了背景之后，可以开始往上加各种的元素了，先把文字内容加上，定位的话，文字放在在页面中间，可以定义一个中点的mx和my，后面很多地方会用到123456let progressWord = new createjs.Text(&apos;政策说明书打开中……&apos;, &apos;30px Microsoft Yahei&apos;, &apos;#637d12&apos;)progressWord.textAlign = &apos;center&apos;progressWord.textBaseline = &apos;bottom&apos;progressWord.x = mxprogressWord.y = my * 1.03container.addChild(progressWord) 加了加载页面的文字之后，就到添加页面的进度条了；由于进度条是图片，所以在添加图片要先用一个预加载，预加载过后，把图片添加到container上面1234567891011121314151617181920212223242526272829let queue = new createjs.LoadQueue(false)queue.on(&apos;complete&apos;, () =&gt; { const loadingProgressImg = queue.getResult(&apos;loadingProgress&apos;) const loadingProgressBitmap = new createjs.Bitmap(loadingProgressImg) const bounds = loadingProgressBitmap.getBounds() loadingProgressBitmap.setTransform(mx - bounds.width * 0.4, my * 0.8, 0.8, 0.8) container.addChild(loadingProgressBitmap) // loading pointer const loadingPointerImg = queue.getResult(&apos;loadingPointer&apos;) const loadingPointerBitmap = new createjs.Bitmap(loadingPointerImg) loadingPointerBitmap.setTransform(mx - bounds.width * 0.4, my * 0.8, 0.8, 0.8) container.addChild(loadingPointerBitmap) callback.call(this, { loadingPointer: loadingPointerBitmap, progressWidth: bounds.width * 0.8, container: container })}, this)queue.loadManifest([ { id: &apos;loadingPointer&apos;, src: loadingPointer }, { id: &apos;loadingProgress&apos;, src: loadingProgress }]) 最后把container添加到stage中 1stage.addChild(container) 加载场景的效果： 加载场景添加动画为加载场景添加动画，需要用到两个preloadjs的方法，progress能够获取加载的进度，complete能够在加载完成之后给与回调方法 123this.queue = new createjs.LoadQueue()this.queue.on(&apos;progress&apos;, progressHandel, this)this.queue.on(&apos;complete&apos;, handleComplete, this) 首先调用progress方法，每加载完成一个资源，通过progress的event参数，调整一遍pointer图片的x坐标，这样就完成了进度条的移动效果 123this.queue.on(&apos;progress&apos;, (event) =&gt; { obj.loadingPointer.x = obj.progressWidth * event.progress + beginX}, this) 完成之后，调用complete方法，切换场景；这里使用了tweenjs的方法，将当前的container不透明度在0.5秒里面变成0，看起来就是一个渐变效果 123456789this.queue.on(&apos;complete&apos;, (event) =&gt; { createjs.Tween.get(obj.container).to({ alpha: 0 }, 500).call(() =&gt; { this.stage.removeChild(obj.container) render.renderStage.call(this) render.renderElement.call(this) })}, this) Createjs搭建长图场景 有了搭建加载场景的经验之后，搭建长图的场景就变得非常容易了。同样先新建一个container，然后加载背景图片，调整大小和位置（这里的背景图的y坐标，需要根据实际情况来修改） 123456789this.container = new createjs.Container()// render backgroundconst background = this.queue.getResult(&apos;bg&apos;)const backgroundImg = new createjs.Bitmap(background)this.rate = this.options.width / 750const stageY = -10726 + this.options.height / this.ratebackgroundImg.setTransform(0, stageY)this.container.addChild(backgroundImg) 注意：无论用什么游戏或者动画框架，只要是用canvas作为底层技术的，必须从底层往上层添加元素，不然上层的元素会被下层覆盖 Createjs制作长按效果 有了背景图之后，先不着急往上面添加元素，因为长图很长，需要先把滚动或者长按效果做出来，方便后面开发 我这里是长按效果，所以需要一个按钮 12345const press = this.queue.getResult(&apos;press&apos;)const pressImg = new createjs.Bitmap(press)pressImg.setTransform(this.options.width * 0.72, this.options.height * 0.5)this.stage.addChild(pressImg)events.pressEvent.call(this, pressImg, this.container) 按钮里面绑定长按事件，这里使用createjs图片元素的mousedown和pressup方法，设置beginMove为true和false 12345678910obj.on(&apos;mousedown&apos;, (e) =&gt; { if (this.stage.getChildAt(2)) { this.stage.removeChild(this.stage.getChildAt(2)) } this.beginMove = true})obj.on(&apos;pressup&apos;, (e) =&gt; { this.beginMove = false}) 设置完之后，其实只是改变一个状态，页面还没有可以动起来，createjs有一个很重要的东西，叫做ticker。可以理解为我们玩游戏时候的fps，每隔一定时间，重新绘制一偏页面 通过调用createjs.Ticker.on(‘tick’, () =&gt; {})， 当beginMove为true的时候，每次ticker重新绘制页面，将container的y坐标就+5，这样就实现了页面长按滚动1234567891011createjs.Ticker.on(&apos;tick&apos;, () =&gt; { if (this.beginMove &amp;&amp; this.container) { // move up let heightLimit = this.rate * 10726 - this.options.height if (this.container.y &lt; heightLimit &amp;&amp; this.container.y + 5 &lt; heightLimit) { this.container.y += 5 } else { this.container.y = heightLimit } }}) Createjs添加元素以及元素动画 有了长按效果之后，页面就可以动了，这个时候就可以把其他元素加入到场景中 这里介绍一个重要的概念：精灵图。 如上图，这种把一张张图片整合在按照一定规律整合在一起的图片，就是精灵图。使用这种图片的好处是加载资源只需要请求一次，其余操作都是用css或者js来对图片进行分割，减少请求次数 而作为游戏和动画领域，这种图片会被经常用到，createjs通过SpriteSheet来处理精灵图；通过定义blubData对象，定义精灵图的宽高以及帧数，就可以把一张精灵图变成动画了 12345678910111213// render blubconst blub = this.queue.getResult(&apos;bulb&apos;)const blubData = { images: [blub], frames: {width: 212 / 2, height: 124, count: 2}, animations: { light: { frames: [0, 1], speed: 0.05 } }}const blubSpriteSheet = new createjs.SpriteSheet(blubData) 新建好了之后，在需要播放的地方使用gotoAndPlay(‘light’)方法播放精灵图动画 1this.blub1Sprite.gotoAndPlay(&apos;light&apos;) 除此之外，对于不是精灵图的图片，可以使用上面用到的加载图片方法 1234const policy = this.queue.getResult(&apos;policy&apos;)this.policyImg = new createjs.Bitmap(policy)this.policyImg.setTransform(700, -1338 + stageY)this.container.addChild(this.policyImg) 然后使用tweenjs来使图片动起来 123createjs.Tween.get(this.policyImg).to({ x: 750 - this.policyImg.getBounds().width}, 1000) 到这里，基本的技术点都已经介绍完了，剩下的就是去加入各种的图片和精灵图这种重复工作 *注意：可能有的小伙伴看到这里会问，为什么我上面写的代码，都有一些-1338 + stageY或者this.rate这种代码。这个其实跟我的需求有关，也是做游戏和动画必须要做的一些兼容性调整。* 最后，给几个createjs的性能优化建议 图片尽量使用精灵图，并进行压缩 尽量不要用滤镜和叠加效果，如果要用，直接做进图片里面 减少容器之间的嵌套 不用的侦听就取消掉，特别是tick 所有基于canvas的引擎都一样，尽量少用旋转，缩放，alpha的操控 尽量重用一些元素","link":"/2018/11/30/CreateJS 制作 H5 长图动画/"}],"tags":[{"name":"Canvas","slug":"Canvas","link":"/tags/Canvas/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"Other","slug":"Other","link":"/tags/Other/"}],"categories":[{"name":"Pixijs","slug":"Pixijs","link":"/categories/Pixijs/"},{"name":"Phaser","slug":"Phaser","link":"/categories/Phaser/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"},{"name":"Other","slug":"Other","link":"/categories/Other/"},{"name":"Createjs","slug":"Createjs","link":"/categories/Createjs/"}]}